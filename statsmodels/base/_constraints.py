"""
Created on Thu May 15 16:36:05 2014

Author: Josef Perktold
License: BSD-3

"""
import numpy as np

class LinearConstraints:
    """Class to hold linear constraints information

    Affine constraints are defined as ``R b = q` where `R` is the constraints
    matrix and `q` are the constraints values and `b` are the parameters.

    This is in analogy to patsy's LinearConstraints class but can be pickled.

    Parameters
    ----------
    constraint_matrix : ndarray
        R matrix, 2-dim with number of columns equal to the number of
        parameters. Each row defines one constraint.
    constraint_values : ndarray
        1-dim array of constant values
    variable_names : list of strings
        parameter names, used only for display
    kwds : keyword arguments
        keywords are attached to the instance.

    """

    def __init__(self, constraint_matrix, constraint_values, variable_names, **kwds):
        self.constraint_matrix = constraint_matrix
        self.constraint_values = constraint_values
        self.variable_names = variable_names
        self.coefs = constraint_matrix
        self.constants = constraint_values
        self.__dict__.update(kwds)
        self.tuple = (self.constraint_matrix, self.constraint_values)

    def __iter__(self):
        yield from self.tuple

    def __getitem__(self, idx):
        return self.tuple[idx]

    def __str__(self):

        def prod_string(v, name):
            v = np.abs(v)
            if v != 1:
                ss = str(v) + ' * ' + name
            else:
                ss = name
            return ss
        constraints_strings = []
        for r, q in zip(*self):
            ss = []
            for v, name in zip(r, self.variable_names):
                if v != 0 and ss == []:
                    ss += prod_string(v, name)
                elif v > 0:
                    ss += ' + ' + prod_string(v, name)
                elif v < 0:
                    ss += ' - ' + prod_string(np.abs(v), name)
            ss += ' = ' + str(q.item())
            constraints_strings.append(''.join(ss))
        return '\n'.join(constraints_strings)

    @classmethod
    def from_patsy(cls, lc):
        """class method to create instance from patsy instance

        Parameters
        ----------
        lc : instance
            instance of patsy LinearConstraint, or other instances that have
            attributes ``lc.coefs, lc.constants, lc.variable_names``

        Returns
        -------
        instance of this class

        """
        return cls(lc.coefs, lc.constants, lc.variable_names)

class TransformRestriction:
    """Transformation for linear constraints `R params = q`

    Note, the transformation from the reduced to the full parameters is an
    affine and not a linear transformation if q is not zero.


    Parameters
    ----------
    R : array_like
        Linear restriction matrix
    q : arraylike or None
        values of the linear restrictions


    Notes
    -----
    The reduced parameters are not sorted with respect to constraints.

    TODO: error checking, eg. inconsistent constraints, how?

    Inconsistent constraints will raise an exception in the calculation of
    the constant or offset. However, homogeneous constraints, where q=0, will
    can have a solution where the relevant parameters are constraint to be
    zero, as in the following example::

        b1 + b2 = 0 and b1 + 2*b2 = 0, implies that b2 = 0.

    The transformation applied from full to reduced parameter space does not
    raise and exception if the constraint does not hold.
    TODO: maybe change this, what's the behavior in this case?


    The `reduce` transform is applied to the array of explanatory variables,
    `exog`, when transforming a linear model to impose the constraints.
    """

    def __init__(self, R, q=None):
        R = self.R = np.atleast_2d(R)
        if q is not None:
            q = self.q = np.asarray(q)
        k_constr, k_vars = R.shape
        self.k_constr, self.k_vars = (k_constr, k_vars)
        self.k_unconstr = k_vars - k_constr
        m = np.eye(k_vars) - R.T.dot(np.linalg.pinv(R).T)
        evals, evecs = np.linalg.eigh(m)
        self.evals = evals
        self.evecs = evecs
        L = self.L = evecs[:, :k_constr]
        self.transf_mat = evecs[:, k_constr:]
        if q is not None:
            try:
                self.constant = q.T.dot(np.linalg.solve(L.T.dot(R.T), L.T))
            except np.linalg.linalg.LinAlgError as e:
                raise ValueError('possibly inconsistent constraints. error generated by\n%r' % (e,))
        else:
            self.constant = 0

    def expand(self, params_reduced):
        """transform from the reduced to the full parameter space

        Parameters
        ----------
        params_reduced : array_like
            parameters in the transformed space

        Returns
        -------
        params : array_like
            parameters in the original space

        Notes
        -----
        If the restriction is not homogeneous, i.e. q is not equal to zero,
        then this is an affine transform.
        """
        params_reduced = np.asarray(params_reduced)
        return self.transf_mat.dot(params_reduced) + self.constant

    def reduce(self, params):
        """transform from the full to the reduced parameter space

        Parameters
        ----------
        params : array_like
            parameters or data in the original space

        Returns
        -------
        params_reduced : array_like
            parameters in the transformed space

        This transform can be applied to the original parameters as well
        as to the data. If params is 2-d, then each row is transformed.
        """
        params = np.asarray(params)
        if params.ndim == 1:
            return self.transf_mat.T.dot(params - self.constant)
        elif params.ndim == 2:
            return (params - self.constant).dot(self.transf_mat)
        else:
            raise ValueError("params must be 1-d or 2-d")

def transform_params_constraint(params, Sinv, R, q):
    """find the parameters that statisfy linear constraint from unconstrained

    The linear constraint R params = q is imposed.

    Parameters
    ----------
    params : array_like
        unconstrained parameters
    Sinv : ndarray, 2d, symmetric
        covariance matrix of the parameter estimate
    R : ndarray, 2d
        constraint matrix
    q : ndarray, 1d
        values of the constraint

    Returns
    -------
    params_constraint : ndarray
        parameters of the same length as params satisfying the constraint

    Notes
    -----
    This is the exact formula for OLS and other linear models. It will be
    a local approximation for nonlinear models.

    TODO: Is Sinv always the covariance matrix?
    In the linear case it can be (X'X)^{-1} or sigmahat^2 (X'X)^{-1}.

    My guess is that this is the point in the subspace that satisfies
    the constraint that has minimum Mahalanobis distance. Proof ?
    """
    params = np.asarray(params)
    R = np.asarray(R)
    q = np.asarray(q)
    
    RSinvR = R.dot(Sinv).dot(R.T)
    RSinvR_inv = np.linalg.inv(RSinvR)
    
    lambda_ = RSinvR_inv.dot(R.dot(params) - q)
    params_constraint = params - Sinv.dot(R.T).dot(lambda_)
    
    return params_constraint

def fit_constrained(model, constraint_matrix, constraint_values, start_params=None, fit_kwds=None):
    """fit model subject to linear equality constraints

    The constraints are of the form   `R params = q`
    where R is the constraint_matrix and q is the vector of constraint_values.

    The estimation creates a new model with transformed design matrix,
    exog, and converts the results back to the original parameterization.


    Parameters
    ----------
    model: model instance
        An instance of a model, see limitations in Notes section
    constraint_matrix : array_like, 2D
        This is R in the linear equality constraint `R params = q`.
        The number of columns needs to be the same as the number of columns
        in exog.
    constraint_values :
        This is `q` in the linear equality constraint `R params = q`
        If it is a tuple, then the constraint needs to be given by two
        arrays (constraint_matrix, constraint_value), i.e. (R, q).
        Otherwise, the constraints can be given as strings or list of
        strings.
        see t_test for details
    start_params : None or array_like
        starting values for the optimization. `start_params` needs to be
        given in the original parameter space and are internally
        transformed.
    **fit_kwds : keyword arguments
        fit_kwds are used in the optimization of the transformed model.

    Returns
    -------
    params : ndarray ?
        estimated parameters (in the original parameterization
    cov_params : ndarray
        covariance matrix of the parameter estimates. This is a reverse
        transformation of the covariance matrix of the transformed model given
        by `cov_params()`
        Note: `fit_kwds` can affect the choice of covariance, e.g. by
        specifying `cov_type`, which will be reflected in the returned
        covariance.
    res_constr : results instance
        This is the results instance for the created transformed model.


    Notes
    -----
    Limitations:

    Models where the number of parameters is different from the number of
    columns of exog are not yet supported.

    Requires a model that implement an offset option.
    """
    if fit_kwds is None:
        fit_kwds = {}

    R, q = constraint_matrix, constraint_values
    tr = TransformRestriction(R, q)

    exog_t = tr.reduce(model.exog)
    offset = model.offset + tr.constant if model.offset is not None else tr.constant
    mod_t = model.__class__(model.endog, exog_t, offset=offset)

    if start_params is not None:
        start_params_t = tr.reduce(start_params)
    else:
        start_params_t = None

    res_t = mod_t.fit(start_params=start_params_t, **fit_kwds)

    params = tr.expand(res_t.params)
    cov_params = tr.transf_mat.dot(res_t.cov_params()).dot(tr.transf_mat.T)

    res_constr = res_t

    return params, cov_params, res_constr

def fit_constrained_wrap(model, constraints, start_params=None, **fit_kwds):
    """fit_constraint that returns a results instance

    This is a development version for fit_constrained methods or
    fit_constrained as standalone function.

    It will not work correctly for all models because creating a new
    results instance is not standardized for use outside the `fit` methods,
    and might need adjustements for this.

    This is the prototype for the fit_constrained method that has been added
    to Poisson and GLM.
    """
    if isinstance(constraints, tuple):
        R, q = constraints
    else:
        R, q = model.get_constraint_matrix(constraints)

    params, cov_params, res_constr = fit_constrained(model, R, q, start_params, fit_kwds)

    # Create a results instance
    res = model.results_class(model, params, cov_params)
    res._results = res_constr
    res.results_constrained = res_constr
    res.constraint_matrix = R
    res.constraint_values = q

    return res
